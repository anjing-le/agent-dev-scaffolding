---
title: 性能优化建议
description: Vue 3 项目性能优化、组件优化、打包优化和内存管理
tags: [性能优化, 懒加载, 虚拟滚动, 打包优化]
---

# 性能优化建议

## 组件优化

### 组件懒加载

```typescript
// ✅ 路由级别懒加载
const routes = [
  {
    path: '/user',
    component: () => import('@views/system/user/index.vue')
  }
]

// ✅ 组件级别懒加载
const HeavyComponent = defineAsyncComponent(() =>
  import('./HeavyComponent.vue')
)

// ✅ 带加载状态的异步组件
const AsyncComponent = defineAsyncComponent({
  loader: () => import('./AsyncComponent.vue'),
  loadingComponent: LoadingSpinner,
  errorComponent: ErrorDisplay,
  delay: 200, // 延迟显示加载组件
  timeout: 3000 // 超时时间
})
```

### 合理拆分组件

```vue
<!-- ❌ 不推荐 - 单个组件过大 -->
<script setup lang="ts">
// 300+ 行代码
// 包含用户列表、搜索、编辑对话框等所有逻辑
</script>

<!-- ✅ 推荐 - 拆分为多个组件 -->
<!-- UserList.vue - 用户列表 -->
<script setup lang="ts">
import UserSearch from './UserSearch.vue'
import UserTable from './UserTable.vue'
import UserDialog from './UserDialog.vue'
</script>

<template>
  <div>
    <UserSearch @search="handleSearch" />
    <UserTable :data="tableData" @edit="handleEdit" />
    <UserDialog v-model="dialogVisible" :user-id="currentUserId" />
  </div>
</template>
```

### 避免不必要的响应式

```vue
<script setup lang="ts">
// ❌ 不推荐 - 静态配置使用 ref
const tableColumns = ref([
  { prop: 'id', label: 'ID' },
  { prop: 'name', label: '姓名' }
])

// ✅ 推荐 - 静态数据不使用响应式
const tableColumns = [
  { prop: 'id', label: 'ID' },
  { prop: 'name', label: '姓名' }
]

// ❌ 不推荐 - 大对象使用深度响应式
const largeData = reactive({
  // 巨大的数据对象
  data: []
})

// ✅ 推荐 - 使用 shallowRef 或 shallowReactive
const largeData = shallowRef({
  data: []
})

// ✅ 推荐 - 只读数据使用 readonly
const config = readonly({
  apiUrl: '/api',
  timeout: 5000
})
</script>
```

## 列表渲染优化

### 使用 key

```vue
<template>
  <!-- ❌ 不推荐 - 使用 index 作为 key -->
  <div v-for="(item, index) in list" :key="index">
    {{ item.name }}
  </div>

  <!-- ✅ 推荐 - 使用唯一 ID 作为 key -->
  <div v-for="item in list" :key="item.id">
    {{ item.name }}
  </div>
</template>
```

### 虚拟滚动

```vue
<script setup lang="ts">
// 对于大量数据的列表，使用虚拟滚动
import { useVirtualList } from '@vueuse/core'

const allItems = ref(Array.from({ length: 10000 }, (_, i) => ({ id: i, name: `Item ${i}` })))

const { list, containerProps, wrapperProps } = useVirtualList(allItems, {
  itemHeight: 50
})
</script>

<template>
  <div v-bind="containerProps" style="height: 400px; overflow: auto">
    <div v-bind="wrapperProps">
      <div v-for="{ data, index } in list" :key="index" style="height: 50px">
        {{ data.name }}
      </div>
    </div>
  </div>
</template>
```

### 分页加载

```vue
<script setup lang="ts">
// ✅ 推荐 - 使用分页而不是一次性加载所有数据
const pagination = reactive({
  current: 1,
  size: 20,
  total: 0
})

const tableData = ref<UserInfo[]>([])

const fetchData = async () => {
  const response = await fetchGetUserList({
    current: pagination.current,
    size: pagination.size
  })
  tableData.value = response.records
  pagination.total = response.total
}

const handlePageChange = (page: number) => {
  pagination.current = page
  fetchData()
}
</script>
```

## 计算属性优化

```vue
<script setup lang="ts">
// ✅ 使用 computed 缓存计算结果
const filteredList = computed(() => {
  return list.value.filter(item => item.status === 'active')
})

// ❌ 不推荐 - 在模板中直接计算
// <div v-for="item in list.filter(item => item.status === 'active')">

// ✅ 复杂计算使用 computed
const statistics = computed(() => {
  const active = list.value.filter(item => item.status === 'active').length
  const inactive = list.value.filter(item => item.status === 'inactive').length
  return { active, inactive, total: list.value.length }
})
</script>
```

## 监听器优化

```vue
<script setup lang="ts">
const keyword = ref('')

// ❌ 不推荐 - 深度监听大对象
watch(
  largeObject,
  () => {
    // 处理逻辑
  },
  { deep: true }
)

// ✅ 推荐 - 只监听需要的属性
watch(
  () => largeObject.value.specificProperty,
  () => {
    // 处理逻辑
  }
)

// ✅ 推荐 - 使用防抖处理高频操作
import { useDebounceFn } from '@vueuse/core'

const debouncedSearch = useDebounceFn((value: string) => {
  fetchData(value)
}, 300)

watch(keyword, (val) => {
  debouncedSearch(val)
})
</script>
```

## 图片优化

### 懒加载

```vue
<template>
  <!-- ✅ 使用原生懒加载 -->
  <img src="/path/to/image.jpg" loading="lazy" alt="描述" />

  <!-- ✅ 使用 VueUse 的 useIntersectionObserver -->
  <div ref="targetRef">
    <img v-if="isVisible" src="/path/to/image.jpg" alt="描述" />
  </div>
</template>

<script setup lang="ts">
import { useIntersectionObserver } from '@vueuse/core'

const targetRef = ref(null)
const isVisible = ref(false)

useIntersectionObserver(
  targetRef,
  ([{ isIntersecting }]) => {
    if (isIntersecting) {
      isVisible.value = true
    }
  }
)
</script>
```

### 图片格式

```vue
<template>
  <!-- ✅ 使用现代图片格式 -->
  <picture>
    <source srcset="/path/to/image.webp" type="image/webp" />
    <source srcset="/path/to/image.jpg" type="image/jpeg" />
    <img src="/path/to/image.jpg" alt="描述" />
  </picture>
</template>
```

### 响应式图片

```vue
<template>
  <!-- ✅ 提供不同尺寸的图片 -->
  <img
    srcset="
      /path/to/image-320w.jpg 320w,
      /path/to/image-640w.jpg 640w,
      /path/to/image-1280w.jpg 1280w
    "
    sizes="(max-width: 320px) 280px, (max-width: 640px) 600px, 1200px"
    src="/path/to/image-640w.jpg"
    alt="描述"
  />
</template>
```

## 请求优化

### 请求防抖和节流

```vue
<script setup lang="ts">
import { useDebounceFn, useThrottleFn } from '@vueuse/core'

// ✅ 防抖 - 搜索输入
const debouncedSearch = useDebounceFn((keyword: string) => {
  fetchSearchResults(keyword)
}, 300)

// ✅ 节流 - 滚动加载
const throttledScroll = useThrottleFn(() => {
  loadMoreData()
}, 200)
</script>
```

### 请求取消

```vue
<script setup lang="ts">
import { fetchGetUserList } from '@/api/system-manage'

let abortController: AbortController | null = null

const fetchData = async () => {
  // 取消之前的请求
  if (abortController) {
    abortController.abort()
  }

  abortController = new AbortController()

  try {
    const response = await fetchGetUserList({
      signal: abortController.signal
    })
    console.log(response)
  } catch (error: any) {
    if (error.name === 'AbortError') {
      console.log('请求已取消')
    }
  }
}

// 组件卸载时取消请求
onUnmounted(() => {
  if (abortController) {
    abortController.abort()
  }
})
</script>
```

### 并发请求

```vue
<script setup lang="ts">
// ✅ 使用 Promise.all 并发请求
const loadPageData = async () => {
  try {
    loading.value = true
    
    const [users, roles, permissions] = await Promise.all([
      fetchGetUserList(),
      fetchGetRoleList(),
      fetchGetPermissions()
    ])
    
    // 处理数据
  } catch (error) {
    console.error(error)
  } finally {
    loading.value = false
  }
}
</script>
```

## 打包优化

### 代码分割

项目已在 `vite.config.ts` 中配置：

```typescript
// vite.config.ts
build: {
  chunkSizeWarningLimit: 2000,
  rollupOptions: {
    output: {
      manualChunks: {
        'element-plus': ['element-plus'],
        'vue-vendor': ['vue', 'vue-router', 'pinia'],
        'echarts': ['echarts']
      }
    }
  }
}
```

### Tree Shaking

```typescript
// ✅ 推荐 - 按需导入
import { ElMessage, ElMessageBox } from 'element-plus'

// ❌ 不推荐 - 全量导入
import ElementPlus from 'element-plus'
```

### 动态导入

```typescript
// ✅ 条件动态导入
const loadChart = async () => {
  if (needChart) {
    const echarts = await import('echarts')
    // 使用 echarts
  }
}
```

## 内存优化

### 清理定时器

```vue
<script setup lang="ts">
let timer: number | null = null

onMounted(() => {
  timer = setInterval(() => {
    // 定时任务
  }, 1000)
})

// ✅ 组件卸载时清理
onUnmounted(() => {
  if (timer) {
    clearInterval(timer)
    timer = null
  }
})
</script>
```

### 清理事件监听

```vue
<script setup lang="ts">
const handleResize = () => {
  // 处理逻辑
}

onMounted(() => {
  window.addEventListener('resize', handleResize)
})

// ✅ 组件卸载时移除监听
onUnmounted(() => {
  window.removeEventListener('resize', handleResize)
})

// 或使用 VueUse 自动清理
import { useEventListener } from '@vueuse/core'

useEventListener(window, 'resize', handleResize)
</script>
```

### 避免内存泄漏

```vue
<script setup lang="ts">
// ❌ 可能导致内存泄漏
const store = useUserStore()
const unsubscribe = store.$subscribe(() => {
  // 订阅逻辑
})
// 忘记取消订阅

// ✅ 正确 - 在卸载时取消订阅
onUnmounted(() => {
  unsubscribe()
})
</script>
```

## Keep-Alive 优化

```vue
<template>
  <!-- ✅ 使用 include 限制缓存的组件 -->
  <router-view v-slot="{ Component }">
    <keep-alive :include="cachedViews" :max="10">
      <component :is="Component" />
    </keep-alive>
  </router-view>
</template>

<script setup lang="ts">
// 只缓存必要的页面
const cachedViews = computed(() => [
  'UserList',
  'RoleList',
  'MenuList'
])
</script>
```

## CSS 优化

### 避免深层选择器

```scss
// ❌ 不推荐
.level1 .level2 .level3 .level4 .level5 {
  color: red;
}

// ✅ 推荐
.level5 {
  color: red;
}
```

### 使用 CSS 变量

```scss
// ✅ 使用 CSS 变量提高性能
:root {
  --primary-color: #409eff;
  --text-color: #333;
}

.button {
  color: var(--primary-color);
}
```

### 避免昂贵的 CSS 属性

```scss
// ❌ 避免使用耗性能的属性
.box {
  box-shadow: 0 0 100px rgba(0, 0, 0, 0.5);
  filter: blur(10px);
}

// ✅ 使用 transform 和 opacity（GPU 加速）
.box {
  transform: translateZ(0);
  will-change: transform;
}
```

## 性能监控

### 使用 Performance API

```typescript
// 测量函数执行时间
export function measurePerformance(name: string, fn: () => void) {
  performance.mark(`${name}-start`)
  fn()
  performance.mark(`${name}-end`)
  performance.measure(name, `${name}-start`, `${name}-end`)
  
  const measure = performance.getEntriesByName(name)[0]
  console.log(`${name} 耗时: ${measure.duration}ms`)
}

// 使用
measurePerformance('fetchData', () => {
  fetchData()
})
```

## 最佳实践总结

1. **组件懒加载**: 路由和大型组件使用懒加载
2. **合理使用响应式**: 静态数据不使用 ref/reactive
3. **虚拟滚动**: 长列表使用虚拟滚动
4. **图片优化**: 懒加载、压缩、使用现代格式
5. **请求优化**: 防抖、节流、取消重复请求
6. **代码分割**: 合理配置 chunk
7. **Keep-Alive**: 限制缓存数量
8. **清理资源**: 卸载时清理定时器和事件监听
9. **使用 computed**: 缓存计算结果
10. **性能监控**: 定期检查性能指标
